# 面向对象

具有类与对象这两种概念的语言机制，并且是以这两种概念来进行组织代码的基本单元，不必强求继承、封装、多态、抽象这四大特性。

## 类

定义了一件事物的抽象特点。类的定义包含了数据的形式以及对数据的操作，也可以说，类定义了**一类事物**的**特征**与**行为**。是构造对象的模板或者蓝图。

### 特征（属性/域）

> **一个类无法访问另一个类的私有属性**

### 行为（方法）

操纵数据的过程。由于JAVA是强类型语言，在调用方法时，编译器会检查这个方法是否存在，若不存在则报错。

#### 特殊行为（特殊方法）

##### 构造器

用来构造实例，名字与类名相同，使用new调用，如果类中**无显示声明构造器**，则默认提供一个**无参构造器**（默认构造方法的访问修饰符和类的访问修饰符相同）。

##### 更改器与访问器

##### 对象析构与finalize方法*

由于JAVA有**垃圾自动回收器**，不需要人工回收内存，所以JAVA不支持析构器。

当对象使用了内存之外的资源，`GC`无法处理，这时可以使用一个**finalize**方法，该方法将在`GC`清除对象之前调用。

***实际中应对稀缺资源时不建议使用，因为很难知道这个方法什么时候才能够调用。***

- `System.runFinalizersOnExit(true)`方法能够确保finalize方法在JAVA关闭前被调用，但是这个方法不安全
- `Runtime.addShutDownHook` 添加“关闭钩”（shutdown hook）
- 如果需要某个资源在使用完后立刻关闭，需要人工管理。应用一个close方法来完成相应的清理操作。

#### 普通行为（普通方法）

##### 参数

- 隐式参数：类的对象，不需显示的列在方法声明中，在方法中习惯用**`this`**指出。

- 显示参数：明显的列在方法声明中
- 按值调用/按引用调用
  1. **基本数据类型（数字、布尔值）**：在使用这种参数类型时，方法不能修改值（方法中的改变对源值无影响）
  2. **对象引用**：方法可以改变引用的对象的状态，但是不能改变引用的值，即将引用指向一个新的对象（这种改变对源引用无效）
  3. ***整体来说，都可以理解为按值调用，因为参数传递对象本质上传递的是对象引用的地址值，所以，当修改参数的引用值时，对该方法外参数的引用无影响。***  



#### 方法重载

**方法名字相同，但是参数不同**，这会产生**重载**，编译器根据**方法名，以及方法参数类型，参数顺序**（**方法签名**）和调用方的值类型与顺序做对比，匹配出相应的方法（这个过程叫做[**重载解析**](#重载解析)）。

### 类间关系

#### 依赖（uses-a）

一个类的**方法操纵**另一个类的对象

#### 聚合（has-a）

一个类的对象的**实例域包含**另一个类的对象

#### 继承（is-a）

用于表示特殊（扩展类，拥有更加个性的属性和方法）与一般（所要扩展的类，一般是比较通用的属性和方法）关系。

另一种表述法是置换法则：表明程序中出现超类对象的任何地方都可以用子类对象置换。

## 对象

是类的实例（Instance）。由类构造（construct）对象的过程称为创建类的实例（instance）

### 特征

#### 状态（state）

对象描述当前特征的信息，会随着时间而变化，但这种改变必须是通过调用对象方法实现（否则就说明该对象封装性遭到破坏）

每个对象都有一组它特有的实例域值的组合，这个组合在当前时刻称为该对象的状态（描述当前特征的信息）。

#### 行为（behavior）

可以对该对象施加哪些操作，通过可调用的方法定义。

#### 标识（identity）

每个对象的唯一身份。

### 初始化

#### 过程

1. 父类静态变量、父类静态代码块
2. 子类静态变量、子类静态代码块
3. 父类非静态变量、父类非静态代码块、父类构造函数
4. 子类非静态变量、子类非静态代码块、子类构造函数

*调用类方法或类变量（**方法或变量是在该类中定义的，而不是继承而来的**），此时会对该类的所有静态域进行初始化* 

##### 细节

###### **首先进行静态域初始化** ：

1. 所有静态域被初始化为默认值
2. 按照在类声明中出现的次序，依次执行所有静态域初始化语句和静态初始化块

###### **其次执行普通实例域初始化** ：

1. 所有数据域被初始化为默认值（***这里要尤为注意，因为`java`对于类的数据域为基本类型的处理，所以对基本类型数据域进行是否为null的判断总是会为false***）
2. 按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块
3. 执行构造器，如果构造器第一行调用了其他构造器，则执行其他构造器主体
4. 执行本构造器主体



## 特征

### 封装

封装主要是隐藏数据，保护数据，提供有限的方法供用户操作数据。封装这一特征是基于语言提供的**访问权限控制**机制来实现的。

#### 意义

1. 访问不受控制，虽然灵活性更强，但是过度的灵活性带来的是不可控性
2. 通过只暴漏必要的接口给用户使用，能够很好的提供易用性，因为用户不需要了解全部的业务实现细节，降低了使用成本

### 继承

通过扩展一个类来建立另一个类，**扩展类具有所扩展类的全部属性和方法**。JAVA是单继承，使用**extends**关键字。继承表示的是`is-a`的关系。

#### 意义

1. 代码复用
2. 清晰的表示类之间（对应到现实中，就是事物之间）的`is-a`关系
3. 不要过度使用继承，会导致类的继承链过长，类之间过度耦合。

***子类对于继承过来的属性与方法的访问，遵守访问控制的约束。*** 

#### 构造器

对于父类的构造器，子类是不会继承的，只是使用super关键字进行调用。

- 对于父类没有无参构造器，子类的构造器中必须使用super调用父类的构造器
- 如果父类中具有无参构造器，或者父类没有显式声明构造器，子类中不必使用super调用父类构造器

#### 覆盖方法（方法重写）

建议使用@Override注解标识出该方法是一个重写方法（可以不用）。使用super关键字调用父类的方法，使用this关键调用自身的方法。

```java
@Override
public double getSalary() {
    return super.getSalary() + bonus;
}
```

##### 重写规则

1. 构造方法无法被重写
2. 子类方法重写父类方法，必须要保证**权限大于等于父类权限**，最好权限修饰一样，不能小于父类权限。
3. 子类方法重写父类方法，返回值类型可以不同，但必须是父类方法返回值类型的派生类；方法名和参数列表都要一模一样。
4. 子类重写父类方法，可以抛出任何非受查异常，对于受查异常，必须是父类抛出的受查异常的派生类。 
5. 子类与父类在**同一个包**中，子类可以重写父类除了final、static、private的所有的方法；不在同一个包中，子类只能重写父类中的public和protected方法
6. @Override写在方法前面，用来检测是不是有效的正确覆盖重写。

##### 重载与重写

1. 重载发生在本类中，重写发生在父类子类中。
2. 重载的方法名必须相同，重写的方法名相同且返回值类型必须相同
3. 重载的参数列表不同，重写的参数列表相同

4. 调用重写方法，与对象运行时类型有关

5. 调用重载方法，只与方法签名中声明的参数类型有关，与对象运行时的具体类型无关

##### 静态属性与静态方法的继承

静态属性和静态方法能够被继承，但是由于静态方法/属性是与类绑定的，所以**父类的会被隐藏**，**静态方法无法被重写**。

当静态方法使用泛型时，由于泛型擦除，可能会导致父类静态方法无法被隐藏（因为擦除前泛型类型的原类型可能是不一样的，，但是类型信息被擦除掉了），会报编译错误

```
both methods have same erasure, yet neither hides the other
```

##### 协变返回值类型和可见性

注意重载方法的返回值类型需要是超类方法返回值类型的子类型；重载方法的可见性不能低于超类方法的可见性。

##### super与this对比

**super** ：

1. 该关键字不是一个对象的引用，不能将super赋给另一个对象变量，它只是一个指示编译器调用父类方法的的特殊关键字。
2. 用于构造器中，调用超类构造器

**this：** 

1. 引用隐式参数
2. 调用该类其他的构造器

### 多态

多态是指一个行为具有多种表现形式的能力。**体现在JAVA中**就是**一个对象变量**可以指示多种**实际类型**的现象。

**多态存在的三个必要条件：**

1. 继承（extends或implement）
2. 重写
3. 父类引用指向子类对象

由于多态，在初始化数组对象时候，一定要牢记数组的类型，避免造成父类引用被当成子类引用，调用不存在于父类的子类引用的方法或实例域从而造成 `ArrayStoreException` ，例如：

```java
Manager[] managers = new Manager[10];
Employee[] staff = managers; // 允许的
staff[0] = new Employee("Harry Hacker", ...);// 编译器允许的

// 此时staff[0]与managers[0]引用同一个对象
managers[0].setBonus(1000) // threw ArrayStoreException
```

#### 实现方式

1. 方法重写
2. 实现接口
3. 抽象类和抽象方法

#### 意义

1. 提高代码的可扩展性

### 抽象

抽象是通过向用户**隐藏方法的具体实现**，使得用户只需关注接口。通常是通过**接口类**与**抽象类**来实现的，一个类的方法（函数）其实已经满足了抽象的概念，使用者只需要根据方法文档来使用方法，不需要了解方法的具体实现方式，不用再抽象出来接口类或者抽象类。

#### 意义

1. 对用户隐藏实现细节，用户需要根据方法文档或方法名、参数来使用方法，不需要关注方法的实现细节。

#### 抽象类

##### 为什么使用抽象类

1. 将通用的方法抽象出来放在抽象类中，**由于抽象类不能被实例化**，所以可以之将其作为基类，而不用去使用抽象类的实例。使用[`abstract`](./附录E-JAVA常用关键字.md) 关键字。
2. 模板方法模式，将具体算法的处理流程在父类中编写好，这样子类就不需要在关注具体的处理流程逻辑了，只需实现各自的构成处理流程的各处理方法的逻辑就好

##### 怎么使用抽象类

- 抽象类中可以没有抽象方法，但是有抽象方法的类必须声明为抽象类

  ```java
  public abstract class Person {
  	public abstract String getDescription();
  }
  ```

  

- 抽象类中可以包含具体的实例域和具体的方法

  ```java
  public abstract class Person {
  	
  	private String name;
  	public Person(String name) {
  		this.name = name;
  	}
  	
  	public String getName() {
  		return this.name;
  	}
  	
  	public abstract String getDescription();
  }
  ```

- 实现抽象类的子类，如果没有或部分定义抽象类中的抽象方法，那么子类必须声明为抽象类；如果定义了全部抽象方法，不必声明抽象类。

- 抽象类不能被实例化，但是可以声明抽象类的变量，引用子类的对象

##### 抽象类中设置构造方法的目的

- 初始化抽象类中的一些属性
- 执行一些必要的逻辑处理，例如：安全检查、参数验证等等

