# 信号量

信号量其实就是一个变量（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来表示系统中某种资源的数量。

用户进程可以通过使用操作系统使用的一对原语来对信号量进行操作，从而很方便的实现了进程互斥、进程同步。

wait原语和signal原语，简称为P、V操作。

## 整型信号量

用一个整数型的变量作为信号量，用来表示系统中某种资源的数量。

<img :src="$withBase='/img/signal-num.png'" class="align-center" />

- 对信号量的操作只有初始化、P、V
- 检查与上锁原子化，避免了并发、异步导致的问题
- 不满足“让权等待”原则，会发生忙等

## 记录型信号量

为了解决整型信号量“忙等”的缺陷。

### 定义

- 记录型信号量定义

```c++
typedef struct {
	int value; // 剩余资源数
	struct process *L; // 等待队列
} semaphore;
```

- wait原语

```c++
void wait (semaphore S) {
	S.value--;
	if (S.value < 0) {
		block(S.L);
	}
}
```

如果剩余资源数不够，使用block原语使进程从运行态进入阻塞态，并把该进程挂到信号量S的等待队列（即阻塞队列）中

- signal原语

```
void signal (semaphore S) {
	S.value++;
	if (S.value <= 0) {
		wakeup(S.L);
	}
}
```

释放资源后，若还有别的进程在等待这种资源，则使用wakeup原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态

## 实现进程互斥

- 分析问题，确定临界区
- 设置互斥信号量，初值为1
- 临界区之前对信号量进行P操作
- 临界区之后对信号量进行V操作

## 实现进程同步

- 分析问题，找出哪里需要实现“一前一后”的同步关系
- 设置同步信号量，初始值为0
- 在“前操作”之后执行V操作
- 在“后操作”之前执行P操作

## 实现进程的前驱关系 

- 分析问题，画出前驱图，把每一对前驱关系都看成一个同步问题
- 为每一对前驱关系设置同步信号量，初值为0
- 在每个“前操作”之后执行V操作
- 在每个“后操作”之前执行P操作
