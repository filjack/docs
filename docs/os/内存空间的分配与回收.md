# 内存空间的分配与回收

## 基本概念

内部碎片：分配给某进程的内存区域中，没有用上的部分

外部碎片：内存中某些空闲分区由于太小而难以利用

## 连续分配管理

**连续分配**：指为用户进程分配的必须是一个连续的内存空间。

### 单一连续分配

<img :src="$withBase='/img/os-singleton-memory-manage.png'" class="align-center" />

#### 基本概念

内存被分为系统区与用户区。内存中**只能有一道用户程序**，该用户程序独占整个用户区空间。

- 系统区：通常位于内存的低地址部分，用于存放操作系统的相关数据
- 用户区：用于存放用户进程相关数据

#### 优缺点

- 优点
  1. 实现简单
  2. 无外部碎片
  3. 可以采用覆盖技术扩充内存
  4. 不一定需要内存保护
- 缺点：
  1. 只能用于单用户、单任务的操作系统
  2. 有内部碎片
  3. 存储器利用率极低

### 固定分区分配

<img :src="$withBase='/img/os-fixed-memory-manage.png'" class="align-center"/>

#### 基本概念

为了支持多道程序处理系统，将用户空间划分为若干个固定大小的额分区，每个分区只装入一道作业。

#### 分类

- 分区大小相等
  缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合。
- 分区大小不等
  增加了灵活性，可以满足不同大小的进程需求。

#### 数据结构

<img :src="$withBase='/img/os-partition-introduction-table.png'" class="align-center"/>

分区说明表，用来实现各个分区的分配与回收。

每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）

当某用户进程要装入内存时，由OS内核程序根据用户程序大小检索该表，找出一个能满足大小的额、未分配的分区分配给该程序，并修改该分区为已分配。

#### 优缺点

- 优点：
  1. 实现简单
  2. 无外部碎片
- 缺点：
  1. 当用户程序太大时，可能所有分区都无法满足需求，这时就需要使用覆盖技术来解决，但这又会降低性能
  2. 产生内部碎片，内存利用率低

### 动态分区分配

#### 基本概念

又叫可变分区分配，它不会预先划分内存分区，而是在进程装入内存时，根据进程大小动态建立分区

#### 数据结构

记录内存的使用情况

- 空闲分区表：每条记录代表一个空闲分区，记录包括分区号、分区大小、分区起始地址、状态等信息
- 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

#### [动态分区分配算法](./动态分区分配算法.md)

#### 分配与回收

- 分配
  - 根据分区分配算法不同进行分配
  - 内存空间总和满足，但是被分成了不连续的部分，可以通过“紧凑”技术来解决外部碎片（合并）
- 回收
  相邻有空闲分区则合并

#### 优缺点

没有内部碎片，但是有外部碎片

## 非连续分配管理

非连续分配：为用户进程分配的可以是一些分散的内存空间。

### 基本分页存储管理

#### 分页存储

<img :src="$withBase='/img/os-memory-page.png'" class="align-center" />

将**内存空间**分为一个个大小相等的分区，每个分区就是一个“**页框**”（页帧、内存块、物理块、物理页面）。每个页框有一个编号（**页框号**），编号**从0开始**。

将**进程的逻辑地址空间**也分为**与页框大小相等**的一个个部分，每个部分称为一个“页”/"**页面**"。每个页面有一个编号，叫**页号**，**从0开始**。

OS以页框为单位为各个进程分配内存空间，进程的每个页面分别放入一个页框中。进程的页面与内存的页框一一对应。各页面无需连续存放。

#### 数据结构

<img :src="$withBase='/img/os-memory-page-table.png'" class="allign-center" />

页表，OS为每个进程建立的，存储在进程的PCB中，存放着进程每个页面与页框的对应关系。

页表中每条记录的大小与页框编号个数有关

#### 地址转换

- 确定逻辑地址的页号

  ```
  页号=逻辑地址/页面长度（页面大小）
  ```

- 确定逻辑地址的页内偏移量

  ```
  页内偏移量=逻辑地址%页面长度
  ```

<img :src="$withBase='/img/os-memory-page-table-example.png'" class="align-center" />

- **如果每个页面大小为2<sup>k</sup>B，用二进制数表示逻辑地址，则末尾k位即为页内偏移量，其余部分就是页号。**
- **如果页面大小刚好是2的整数幂，则只需要把页表中记录的页框号（转二进制）拼接上页内偏移量（转二进制）就能得到对应的物理地址（二进制）**

#### 基本地址变换机构

借助进程的页表将逻辑地址转换为物理地址。（用于实现逻辑地址到物理地址转换的一组硬件机构）

**页表寄存器（PTR）**，用于存放页表在内存中**起始地址F**和**页表长度M**。进程未执行时，F、M放在**PCB**中，当进程被调度时，OS内核会将它们放到**PTR**中。

- 页内偏移量占10位，说明一个页面的大小为2<sup>10</sup>B=1KB
- 在分页存储管理（页式管理）的系统中，只要确认了页面大小，逻辑结构就确定了，因为系统可以自动算出页号、页内偏移量。所以页式管理中地址是一维的。
- 为了方便页表查询，常常让一个页表占更多的字节，使得每个页面恰好可以装的下整数个页表记录