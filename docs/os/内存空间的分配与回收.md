# 内存空间的分配与回收

## 基本概念

内部碎片：分配给某进程的内存区域中，没有用上的部分

外部碎片：内存中某些空闲分区由于太小而难以利用

## 连续分配管理

**连续分配**：指为用户进程分配的必须是一个连续的内存空间。

### 单一连续分配

<img :src="$withBase='/img/os-singleton-memory-manage.png'" class="align-center" />

#### 基本概念

内存被分为系统区与用户区。内存中**只能有一道用户程序**，该用户程序独占整个用户区空间。

- 系统区：通常位于内存的低地址部分，用于存放操作系统的相关数据
- 用户区：用于存放用户进程相关数据

#### 优缺点

- 优点
  1. 实现简单
  2. 无外部碎片
  3. 可以采用覆盖技术扩充内存
  4. 不一定需要内存保护
- 缺点：
  1. 只能用于单用户、单任务的操作系统
  2. 有内部碎片
  3. 存储器利用率极低

### 固定分区分配

<img :src="$withBase='/img/os-fixed-memory-manage.png'" class="align-center"/>

#### 基本概念

为了支持多道程序处理系统，将用户空间划分为若干个固定大小的额分区，每个分区只装入一道作业。

#### 分类

- 分区大小相等
  缺乏灵活性，但是很适合用于用一台计算机控制多个相同对象的场合。
- 分区大小不等
  增加了灵活性，可以满足不同大小的进程需求。

#### 数据结构

<img :src="$withBase='/img/os-partition-introduction-table.png'" class="align-center"/>

分区说明表，用来实现各个分区的分配与回收。

每个表项对应一个分区，通常按分区大小排列。每个表项包括对应分区的大小、起始地址、状态（是否已分配）

当某用户进程要装入内存时，由OS内核程序根据用户程序大小检索该表，找出一个能满足大小的额、未分配的分区分配给该程序，并修改该分区为已分配。

#### 优缺点

- 优点：
  1. 实现简单
  2. 无外部碎片
- 缺点：
  1. 当用户程序太大时，可能所有分区都无法满足需求，这时就需要使用覆盖技术来解决，但这又会降低性能
  2. 产生内部碎片，内存利用率低

### 动态分区分配

#### 基本概念

又叫可变分区分配，它不会预先划分内存分区，而是在进程装入内存时，根据进程大小动态建立分区

#### 数据结构

记录内存的使用情况

- 空闲分区表：每条记录代表一个空闲分区，记录包括分区号、分区大小、分区起始地址、状态等信息
- 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息

#### [动态分区分配算法](./动态分区分配算法.md)

#### 分配与回收

- 分配
  - 根据分区分配算法不同进行分配
  - 内存空间总和满足，但是被分成了不连续的部分，可以通过“紧凑”技术来解决外部碎片（合并）
- 回收
  相邻有空闲分区则合并

#### 优缺点

没有内部碎片，但是有外部碎片

## 非连续分配管理