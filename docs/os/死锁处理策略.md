# 死锁处理策略

## 预防死锁（静态策略）

### 破坏互斥条件

将临界资源改造为可共享使用的资源（`SPOOLing`技术）

缺点：

1. 可行性不高，很多时候无法破坏互斥条件

### 破坏不剥夺条件

方案一：

申请的资源得不到满足时，立即释放拥有的所有资源

方案二：

申请的资源被其他进程占用时，由操作系统协助剥夺（考虑优先级）

缺点：

1. 实现复杂
2. 剥夺资源可能导致部分工作失效
3. 反复申请和释放导致系统开销大
4. 可能导致饥饿

### 破坏请求和保持条件

静态分配：运行前分配好所有需要的资源，之后一直保持

缺点：

1. 资源利用率低
2. 可能导致饥饿

### 破坏循环等待条件

给资源编号，必须按编号从小到大的顺序申请资源

缺点：

1. 不方便增加新设备
2. 会导致资源浪费
3. 用户编程麻烦

## 避免死锁（动态策略）

### 基本概念

#### 安全序列

如果系统按照某个序列分配资源，且每个进程都能顺利完成，只要找出一个该序列，则系统就是安全状态。安全序列可能有多个。

#### 不安全状态

如果系统找不出一个安全序列，那么系统就处于不安全状态，这意味着可能所有进程都无法顺利的执行下去。当然，如果有进程提前归还了一些资源，那系统也有可能重新回到安全状态。

#### 与死锁的关系

如果系统处于安全状态，则一定不会发生死锁；如果处于不安全状态，则有可能发生死锁。

### 银行家算法

在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

#### 算法步骤

1. 检查此次申请是否超过了之前声明的最大需求数
2. 检查此时系统剩余的可用资源是否还能满足这次请求
3. 试探着分配，更改各数据结构
4. 用安全性算法检查此次分配是否会导致系统进入不安全状态

#### 安全性算法步骤

1. 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该进程持有的资源全部回收
2. 不断重复上述过程，看最终是否能让所有进程都加入安全序列

## 死锁的检测与解除

### 检测

1. 使用某种数据结构来保存资源的请求和分配信息
   <img :src="$withBase='/img/os-check-dead-lock-structure.png'" class="align-center"/>
2. 提供一种算法，利用保存的信息来检测系统是否已进入死锁状态
   - 依次消除与不阻塞进程相连的边，直到无边可消（不阻塞进程是指其申请的资源还足够的进程）
   - 死锁定理：若资源分配图是不可完全简化的，说明发生了死锁

### 解除

#### 资源剥夺法

挂起（暂时放到外存上）某些进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。

#### 撤销进程法

或称（终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。优点是实现简单，但是所付出的代价可能会很大，因为有些进程可能已经运行了很长时间，已经接近结束了，一旦被终止可谓功亏一篑，以后还得从头再来

#### 进程回退法

让一个或多个死锁进程回退到足以避免死锁的地步。这要求系统要记录进程的历史信息，设置还原点。

#### 挑选进程的原则

1. 进程优先级
2. 已执行多长时间
3. 还要多久能完成
4. 进程已经使用了多少资源
5. 进程是交互式的还是批处理式的