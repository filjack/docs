#  调度算法

## 评价指标

### CPU利用率

CPU“忙碌”时间占总时间的比例

`CPU利用率=CPU忙碌时间/总时间`

### 系统吞吐量

单位时间完成作业的数量

`系统吞吐量=总共完成了多少道作业/总共花费了多少时间`

### 周转时间

指从作业被提交到系统，到作业被完成这段时间间隔。

`周转时间=作业完成时间-作业提交时间`

`平均周转时间=各作业周转时间之和/作业数`

`带权周转时间=作业周转时间/作业实际运行时间`

`平均带权周转时间=各作业带权周转时间之和/作业数`

#### 组成

- 作业在外存后备队列上等待作业调度的时间
- 进程在就绪队列上等待进程调用的时间
- 进程在CPU上运行的时间
- 进程等待I/O操作完成的时间



### 等待时间

指进程/作业处于等待处理机状态的时间之和。

#### 分类

- 进程：等待时间是指进程建立后等待被服务的时间之和，在等待I/O完成的期间其实进程也是在被服务，所以不计入等待时间
- 作业：不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中的等待时间。

一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。

### 响应时间

指从用户提交请求到首次产生响应所用的时间。

## 早期批处理系统

### 先来先服务（FCFS）

#### 算法思想

主要从“公平”的角度考虑

#### 算法规则

按照作业/进程到达的先后顺序进行服务

#### 用于作业/进程调度

用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列

#### 是否可抢占

非抢占式的算法

#### 优点

公平、算法实现简单

#### 缺点

排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对于短作业来说用户体验不好。即，FCFS算法对于长作业有利，对于短作业不利

#### 是否会导致饥饿

不会

### 短作业优先（SJF）

#### 算法思想

追求最少的平均等待时间，最少的平均周转时间、最少的平均带权周转时间

#### 算法规则

最短的作业/进程优先得到服务（所谓“最短”，是指要求服务时间最短）

#### 用于作业/进程调度

既可用于作业调度，也可用于进程调度。用于进程调度时称为“短进程优先算法（SPF）”

#### 是否可抢占

- SJF/SPF是非抢占式算法
  每次调度时选择当前已经到达且运行时间最短的作业/进程
- 最短剩余时间优先算法（SRTN）是抢占式算法（**该算法的平均周转时间，平均等待时间最短，当进程基本上可以同时到达时**）
  每当有进程加入就绪队列（就绪队列改变）时就需要调度，如果新到达的进程运行时间比当前运行的进程的剩余运行时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列。另外，当一个进程完成时（正常终止）也需要调度

#### 优点

“最短的”平均等待时间、平均周转时间

#### 缺点

不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先

#### 是否会导致饥饿

会。如果源源不断地有短作业/进程到来，可能使得长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”

### 高响应比优先（HRRN）

#### 算法思想

要综合考虑作业/进程的等待时间和要求服务的时间

#### 算法规则

在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务

`响应比=(等待时间+要求服务时间)/要求服务时间`

#### 用于作业/进程调度

既可用于作业调度，也可用于进程调度

#### 是否可抢占

非抢占式算法。因此只有当前运行的作业/进程主动放弃处理机时（正常/异常完成，或主动阻塞），才需要调度，调度时计算所有就绪进程的响应比，选最高的进程上处理机

#### 优/缺点

综合考虑了等待时间和运行时间（要求服务时间）；等待时间相同时，运行时间短的优先（SJF优点）；运行时间相同时，等待时间长的优先（FCFS优点）；对于长作业来说，随着等待时间越来越长，其响应比也会越来越大，从而避免了长作业饥饿的问题

#### 是否会导致饥饿

不会

## 交互式系统

### 时间片轮转调度算法（RR）

#### 算法思想

公平地、轮流地为各个进程服务，让每一个进程在一定时间间隔内都可以得到响应

#### 算法规则

按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队

#### 用于作业/进程调度

用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）

#### 是否可抢占

若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于抢占式的算法。由时钟装置发出时钟中断来通知CPU时间片已到

#### 优点

公平、响应快、适用于分时操作系统

#### 缺点

由于高频率的进程切换，因此有一定开销；不区分任务的紧急程序

#### 是否会导致饥饿

不会

#### 时间片的选择

- 太大：使得每一个进程都可以在一个时间片内完成，则时间片轮转调度算法退化为先来先服务算法，并且会增大进程响应时间。
- 太小：因为进程的调度、切换是有时间代价的（保存、恢复运行环境），因此如果太小，会导致进程切换过于频繁，系统会花大量时间来处理进程切换，从而导致实际用于进程执行的时间比例减少
- 一般来说，设计时间片时要让切换进程的开销占比不超过1%

### 优先级调度算法

#### 算法思想

需要根据任务的紧急程度来决定任务的处理顺序

#### 算法规则

每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程

#### 用于作业/进程调度

既可用于作业调度，也可用于进程调度。甚至，还会用于I/O调度

#### 是否可抢占

抢占式、非抢占式都有。区别是：非抢占式只需要在进程主动放弃处理机时进行调度即可，抢占式则还需在就绪队列变化时，检查是否会发生抢占

#### 优点

用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度

#### 缺点

若源源不断地有高优先级进程到来，则可能导致饥饿

#### 是否会导致饥饿

会

#### 优先级

就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在靠近队头的位置。

##### 分类

根据优先级是否可以动态改变分

- 静态优先级：创建进程时确定，之后一直不变
- 动态优先级：创建进程时有一个初始值，之后会根据情况动态地调整优先级

##### 如何合理设置各类进程优先级

- 系统进程优先级高于用户进程
- 前台进程优先级高于后台进程
- 操作系统更偏好I/O型进程[^1]

##### 动态优先级策略，什么时候调整优先级

可以从追求公平、提升资源利用率等角度考虑

- 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级
- 如果某进程占用处理机运行了很长时间，则可以适当降低其优先级
- 如果发现了一个进程频繁地进行I/O操作，则可适当提升其优先级

### 多级反馈队列调度算法

#### 算法思想

对其他调度算法的折中权衡

#### 算法规则

1. 设置多级就绪队列，各级队列优先级从高到低，时间片从小到大
2. 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾
3. 只有第k级队列为空时，才会为k+1级队头的进程分配时间片
4. 各队列内部可以设置不同的调度算法，取决于当前队列的特征与需求

#### 用于作业/进程调度

用于进程调度

#### 是否可抢占

抢占式算法。在k级队列的进程运行过程中，若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。

#### 优缺点

- 对各类型进程相对公平（FCFS优点）
- 每个新到达的进程都可以很快得到响应（RR优点）
- 短进程只用较少的时间就可以完成（SPF优点）
- 不必实现估计进程的运行时间（避免用户作假）
- 可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）

#### 是否会导致饥饿

会





[^1]: 又称作I/O繁忙型进程，相对的是计算型进程（CPU繁忙型进程）。I/O设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升