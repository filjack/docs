# 进程

## 基本概念

### 程序

静态的，存放在磁盘中的可执行文件，是一些列指令的集合。

### 进程

动态的，是程序的一次执行过程。同一个程序多次执行对应多个进程。

进程是进程实体的执行过程，是系统进行资源分配和调度（是指操作系统指定该进程上CPU运行）的独立单位。

### 进程实体

静态的，反映了进程在某一时刻的状态。

## 组成

*准确来讲，是进程实体的组成。*

### PCB

PCB（process control block，进程控制块），存放着操作系统在对各个并发运行的进程进行管理时所需要的信息。是进程存在的唯一标志，当进程被创建时，该进程的PCB被创建，当进程结束时，该进程的PCB被回收。

#### 组成

- 进程描述信息
  -   进程标识符PID
  -   用户标识符UID
- 进程控制和管理信息
  - CPU、磁盘、网络流量使用情况统计
  - 进程当前状态：就绪态/阻塞态/运行态
- 资源分配清单
  - 正在使用那些文件
  - 正在使用那些内存区域
  - 正在使用那些I/O设备
- 处理机相关信息
  - 如PSW、PC等等寄存器的值（用于实现进程切换）

### 程序段

程序的代码（指令序列）

### 数据段

运行过程钟产生的各种数据（例如：程序中定义的变量）

## 特征

- 动态性
  进程是程序的一次执行过程，是动态地产生、变化、和消亡的；进程最基本的特征
- 并发性
  内存中有多个进程实体，各进程可并发执行
- 独立性
  进程是能独立运行、独立获取资源的基本单位
- 异步性
  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题
- 结构性
  每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成



## 状态

进程PCB中，会有一个变量state来表示进程的当前状态。

### 创建态

**new**

进程正在被创建时，处于创建态，该阶段操作系统为进程分配资源，初始化PCB

### 就绪态（基本状态）

**ready**

进程创建完成后，进入就绪态，此时进程具备运行条件，但由于CPU无空闲，所以暂时不能运行

### 运行态（基本状态）

**running**

进程正在CPU上运行，则该进程处于运行态。CPU会执行该进程对应的程序（执行指令序列）

### 阻塞态（基本状态）

**waiting/blocked**

在进程运行过程中，如果发生请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应，这是进程主动发生的）。在该事件发生前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态。

当CPU空闲时，又会选择另一个就绪态的进程上CPU运行。

### 终止态

**terminated**

一个进程可以执行exit系统调用，请求操作系统终止该进程。此时进程进入终止态，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，这个进程就彻底消失了。

## 状态转换

<img :src="$withBase='/img/os-process-status-changing.png'" class="align-center" />

## 组织

为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。

### 链接方式

<img :src="$withBase='/img/os-process-linked.png'" class="align-center" />

- 按照进程状态将PCB分为多个队列
- 操作系统持有指向各个队列的指针

### 索引方式

<img :src="$withBase='/img/os-process-index.png'" class="align-center"/>

- 根据进程状态的不同，建立几张索引表
- 操作系统持有指向各个索引表的指针

## 进程控制

进程控制就是要实现进程状态的转换。

### 实现方式

采用原语实现。因为原语具有原子性。原语使用两条特权指令来实现原子性，关中断指令和开中断指令。CPU执行关中断指令后，将不再例行检查是否收到外部中断信号，直到CPU执行开中断指令。

### 使用的原语

- 创建原语
  <img :src="$withBase='/img/os-create-primitive.png'" class="align-center" />
- 撤销原语
  <img :src="$withBase='/img/os-recall-primitive.png'" class="align-center"/>
- 阻塞和唤醒原语
  <img :src="$withBase='/img/os-waiting-primitive.png'" class="align-center"/>
- 切换原语
  <img :src="$withBase='/img/os-change-primitive.png'" class="align-center"/>

## 进程通信（IPC）

进程通信是指两个进程间产生数据交互。进程间通信需要操作系统支持，因为进程是分配系统资源的单位，因此各个进程拥有的内存地址空间是相互独立的，进程不能直接访问其他进程的内存地址空间。

### 共享存储

<img :src="$withBase='/img/os-ipc-share-commuication.png'" class="align-center"/>

操作系统在内存中设置一个共享存储区，需要进行通信的进程将其映射到自己的虚拟地址空间。共享存储区在进程间访问是互斥的，一个时间段内只能有一个进程进行访问，这种互斥是由通信进程自己实现的。

- 基于数据结构的共享（低级共享）
  共享区中只能存放符合要求的数据结构，灵活性差，效率低
- 基于存储区的共享（高级共享）
  操作系统在内存中划出共享区，但是数据的结构，存储地址等都由进程自行控制，灵活性好，效率高

### 消息传递

以结构化的消息为单位，通过使用由操作系统提供的“发送消息/接受消息”原语来进行通信。

- 直接通信方式
  消息头包括了接收方和发送方的进程ID，消息直接挂接到接受进程的消息队列中
  <img :src="$withBase='/img/os-ipc-msg-directly.png'" class="align-center"/>
- 间接（信箱）通信方式
  通过“信箱”来进行消息传递。发送方指明发送到哪个信箱中，接受方指明接受哪个信箱的消息。
  <img :src="$withBase='/img/os-ipc-msg-indirectly.png'" class="align-center"/>

### 管道通信

<img :src="$withBase='/img/os-ipc-pipe.png'" class="align-center"/>

通过设置一个特殊的共享文件（pipe文件），在内存中开辟出一块内存缓冲区，管道就像一个循环队列一样，消息先进先出，且在同一时间段内只能由一方发送，另一方接受。

#### 特点

- 半双工通信
- 各进程要互斥访问，即，当一个进程正在读/写时，其他进程只能等待（由操作系统负责实现互斥）
- 管道满时，写进程阻塞，直到管道非满；管道空时，读进程阻塞，直到管道非空
- 管道数据一旦读出，就彻底消失。当多个读进程读一个管道时，可能会发生混乱，解决办法：
  1. 多个写进程，一个读进程（system5操作系统）
  2. 多个读/写进程，由操作系统控制读进程来轮流读（Linux操作系统）