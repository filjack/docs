# 进程互斥

## 软件实现方法

### 单标志法

<img :src="$withBase='/img/os-process-sync1.png'" class="align-center" />

- 进程在进入区只”检查“，不”上锁“
- 在退出区把临界区的使用权转交给另一个进程

#### 主要问题

不遵守”空闲让进“原则

### 双标志先检查法

<img :src="$withBase='/img/os-process-sync2.png'" class="align-center" />

- 在进入区先”检查“后”上锁“，退出区”解锁“

#### 主要问题

不遵守”忙则等待“原则

### 双标志后检查法

<img :src="$withBase='/img/os-process-sync3.png'" class="align-center" />

- 在进入区先”加锁“后检查，退出区”解锁“

#### 主要问题

不遵循”空闲让进、有限等待“原则，可能会导致”饥饿“

### Peterson算法

<img :src="$withBase='/img/os-process-sync4.png'" class="align-center" />

- 在进入区”主动争取-主动谦让-检查对方是否想进、己方是否谦让“

#### 主要问题

不遵循”让权等待“原则，会发生”忙等“

## 硬件实现方法

### 中断屏蔽方法

使用”开/关中断指令“实现。

#### 优点

简单、高效

#### 缺点

不适用于多处理机；只适用于操作系统内核进程，不适用于用户进程（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）

### TestAndSet方法

又叫TS指令/TSL指令，使用硬件实现，相较于软件实现方法，TSL指令把”上锁“和”检查“操作用硬件的方式变成了一气呵成的原子操作。

<img :src="$withBase='/img/os-process-sync-tsl.png'" class="align-center"/>

#### 优点

实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

#### 缺点

不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“

### Swap方法

又叫EXCHANGE指令/XCHG指令，使用硬件实现

<img :src="$withBase='/img/os-process-sync-swap.png'" class="align-center"/>

#### 优点

实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；适用于多处理机环境

#### 缺点

不满足”让权等待“原则，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致”忙等“

## 锁

### 互斥锁（mutex lock）

一个进程在进入临界区时应获得锁；在退出临界区时释放锁。这两个操作都是原子的

#### 缺点

进程在等待其他进程释放锁的过程中，造成CPU的忙等待

#### 分类

##### 自旋锁（spin lock）

需要连续循环忙等待的互斥锁。如TSL指令，swap指令，单标志法

#### 特性

- 需要忙等，进程时间片用完才下处理机，违反”让权等待“
- 等待期间不用切换进程上下文，多处理器系统中，若上锁时间短，则等待代价很低
- 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区
- 不太适用于单处理机系统，忙等的过程不可能解锁