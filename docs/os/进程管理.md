# 进程管理

## 进程

### 基本概念

#### 程序

静态的，存放在磁盘钟的可执行文件，是一些列指令的集合。

#### 进程

动态的，是程序的一次执行过程。同一个程序多次执行对应多个进程。

进程是进程实体的执行过程，是系统进行资源分配和调度（是指操作系统指定该进程上CPU运行）的独立单位。

#### 进程实体

静态的，反映了进程在某一时刻的状态。

### 组成

*准确来讲，是进程实体的组成。*

#### PCB

PCB（process control block，进程控制块），存放着操作系统在对各个并发运行的进程进行管理时所需要的信息。是进程存在的唯一标志，当进程被创建时，该进程的PCB被创建，当进程结束时，该进程的PCB被回收。

##### 组成

- 进程描述信息
  -   进程标识符PID
  -   用户标识符UID
- 进程控制和管理信息
  - CPU、磁盘、网络流量使用情况统计
  - 进程当前状态：就绪态/阻塞态/运行态
- 资源分配清单
  - 正在使用那些文件
  - 正在使用那些内存区域
  - 正在使用那些I/O设备
- 处理机相关信息
  - 如PSW、PC等等寄存器的值（用于实现进程切换）

#### 程序段

程序的代码（指令序列）

#### 数据段

运行过程钟产生的各种数据（例如：程序中定义的变量）

### 特征

- 动态性
  进程是程序的一次执行过程，是动态地产生、变化、和消亡的；进程最基本的特征
- 并发性
  内存中有多个进程实体，各进程可并发执行
- 独立性
  进程是能独立运行、独立获取资源的基本单位
- 异步性
  各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题
- 结构性
  每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成



### 状态

进程PCB中，会有一个变量state来表示进程的当前状态。

#### 创建态

**new**

进程正在被创建时，处于创建态，该阶段操作系统为进程分配资源，初始化PCB

#### 就绪态（基本状态）

**ready**

进程创建完成后，进入就绪态，此时进程具备运行条件，但由于CPU无空闲，所以暂时不能运行

#### 运行态（基本状态）

**running**

进程正在CPU上运行，则该进程处于运行态。CPU会执行该进程对应的程序（执行指令序列）

#### 阻塞态（基本状态）

**waiting/blocked**

在进程运行过程中，如果发生请求等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应，这是进程主动发生的）。在该事件发生前，进程无法继续往下执行，此时操作系统会让这个进程下CPU，并让它进入阻塞态。

当CPU空闲时，又会选择另一个就绪态的进程上CPU运行。

#### 终止态

**terminated**

一个进程可以执行exit系统调用，请求操作系统终止该进程。此时进程进入终止态，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。当终止进程的工作完成之后，这个进程就彻底消失了。

### 状态转换

<img :src="$withBase='/img/os-process-status-changing.png'" class="align-center" />

### 组织

为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。

#### 链接方式

<img :src="$withBase='/img/os-process-linked.png'" class="align-center" />

- 按照进程状态将PCB分为多个队列
- 操作系统持有指向各个队列的指针

#### 索引方式

<img :src="$withBase='/img/os-process-index.png'" class="align-center"/>

- 根据进程状态的不同，建立几张索引表
- 操作系统持有指向各个索引表的指针

### 进程控制

进程控制就是要实现进程状态的转换。

#### 实现方式

采用原语实现。因为原语具有原子性。原语使用两条特权指令来实现原子性，关中断指令和开中断指令。CPU执行关中断指令后，将不再例行检查是否收到外部中断信号，直到CPU执行开中断指令。

#### 使用的原语

- 创建原语
  <img :src="$withBase='/img/os-create-primitive.png'" class="align-center" />
- 撤销原语
  <img :src="$withBase='/img/os-recall-primitive.png'" class="align-center"/>
- 阻塞和唤醒原语
  <img :src="$withBase='/img/os-waiting-primitive.png'" class="align-center"/>
- 切换原语
  <img :src="$withBase='/img/os-change-primitive.png'" class="align-center"/>

### 进程通信（IPC）

进程通信是指两个进程间产生数据交互。进程间通信需要操作系统支持，因为进程是分配系统资源的单位，因此各个进程拥有的内存地址空间是相互独立的，进程不能直接访问其他进程的内存地址空间。

#### 共享存储

<img :src="$withBase='/img/os-ipc-share-commuication.png'" class="align-center"/>

操作系统在内存中设置一个共享存储区，需要进行通信的进程将其映射到自己的虚拟地址空间。共享存储区在进程间访问是互斥的，一个时间段内只能有一个进程进行访问，这种互斥是由通信进程自己实现的。

- 基于数据结构的共享（低级共享）
  共享区中只能存放符合要求的数据结构，灵活性差，效率低
- 基于存储区的共享（高级共享）
  操作系统在内存中划出共享区，但是数据的结构，存储地址等都由进程自行控制，灵活性好，效率高

#### 消息传递

以结构化的消息为单位，通过使用由操作系统提供的“发送消息/接受消息”原语来进行通信。

- 直接通信方式
  消息头包括了接收方和发送方的进程ID，消息直接挂接到接受进程的消息队列中
  <img :src="$withBase='/img/os-ipc-msg-directly.png'" class="align-center"/>
- 间接（信箱）通信方式
  通过“信箱”来进行消息传递。发送方指明发送到哪个信箱中，接受方指明接受哪个信箱的消息。
  <img :src="$withBase='/img/os-ipc-msg-indirectly.png'" class="align-center"/>

#### 管道通信

<img :src="$withBase='/img/os-ipc-pipe.png'" class="align-center"/>

通过设置一个特殊的共享文件（pipe文件），在内存中开辟出一块内存缓冲区，管道就像一个循环队列一样，消息先进先出，且在同一时间段内只能由一方发送，另一方接受。

##### 特点

- 半双工通信
- 各进程要互斥访问，即，当一个进程正在读/写时，其他进程只能等待（由操作系统负责实现互斥）
- 管道满时，写进程阻塞，直到管道非满；管道空时，读进程阻塞，直到管道非空
- 管道数据一旦读出，就彻底消失。当多个读进程读一个管道时，可能会发生混乱，解决办法：
  1. 多个写进程，一个读进程（system5操作系统）
  2. 多个读/写进程，由操作系统控制读进程来轮流读（Linux操作系统）

## 线程

线程是一个基本的CPU执行单元，是程序执行流的最小单位。可以理解为一个“轻量级的继承”。

### 为什么引入线程

进程可能需要“同时”做很多事情，而传统的进程只能串行的执行一系列程序。为此，引入线程，来增加并发度，不仅进程间可以并发，进程内各线程间也可以并发。

### 进入线程之后带来的变化

- 资源分配、调用
  -   之前：传统进程机制中，进程是资源分配、调度的基本单位
  -   之后：进程是资源分配的基本单位，线程是调度的基本单位
- 并发性
  - 之前：只能进程间并发
  - 之后：各线程间也能并发，提升了并发性
- 系统开销
  - 之前：进程间并发，需要切换进程的运行环境，系统开销很大
  - 之后：线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小

### 属性

- 线程是处理机调度的单位
- 多CPU计算机中，各个线程可占用不同的CPU
- 每个线程都有一个线程ID，线程控制块（TCB）
- 线程也有就绪、阻塞、运行三种基本状态
- 线程几乎不拥有系统资源
- 同一进程的不同线程间共享进程的资源
- 由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预
- 同一进程中的线程切换，不会引起进程切换
- 不同进程中的线程切换，会引起进程切换
- 切换同进程内的线程，系统开销很小
- 切换进程，系统开销很大

### 实现方式

#### 用户级线程（User-Level Thread）

<img :src="$withBase='/img/os-thread-ult.png'" class="align-center"/>

早期的操作系统（例如Unix）只支持进程，不支持线程。当时的“线程”是由线程库实现的。

- 线程管理工作由应用进程通过线程库来完成
- 线程切换不需要CPU由用户态转换为内核态
- 操作系统意识不到用户级线程的存在
- 优点：用户级线程管理不需要CPU切换到内核态，所以线程管理开销小，效率高
- 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不能在多核处理机上并行运行

#### 内核级线程（Kernel-Level Thread）

<img :src="$withBase='/img/os-thread-klt.png'" class="align-center"/>

又叫内核支持线程，是由操作系统支持的线程，现代大多数操作系统都实现了内核级线程，如windows、Linux。**操作系统只能“看得见”内核级线程，因此内核级线程才是处理机分配的单位。**

- 线程管理工作由操作系统完成
- 线程切换需要CPU变态，因为涉及到从用户线程到对应的内核支持线程的映射
- 操作系统能够意识到内核级线程的存在
- 优点：某个线程阻塞后，别的线程可以继续执行，线程之间的并发能力强，多线程可在多核处理机上并行执行
- 缺点：线程切换需要变态，线程管理成本高，开销大

#### 组合方式

在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系进行划分

##### 一对一模型

<img :src="$withBase='/img/os-muti-thread-one-to-one.png'" class="align-center"/>

一个用户级线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程

- 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可以在多核处理机上并行执行
- 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理成本高，开销大

##### 多对一模型

<img :src="$withBase='/img/os-muti-thread-more-to-one.png'" class="align-center"/>

多个用户级线程映射到一个内核级线程。且一个进程只被分配一个内核级线程。

- 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高

- 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行

##### 多对多模型

<img :src="$withBase='/img/os-muti-thread-more-to-more.png'" class="align-center"/>

n用户级线程映射到m个内核级线程（n>=m）。每个用户进程对应m个内核级线程。

- 优点：克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

### 状态与转换

<img :src="$withBase='/img/os-thread-status-change.png'" class="align-center" />

### 组织与控制

<img :src="$withBase='/img/os-thread-orgnization.png'" class="align-center" />
