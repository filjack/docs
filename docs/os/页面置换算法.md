# 页面置换算法

> 页面的换入、换出需要磁盘I/O，会有较大的开销，因此好的页面置换算法应该追求更少的缺页率

## 最佳置换算法（OPT）

每次选择淘汰的页面将是**以后永不使用**，或者在**最长时间内不再被访问**的页面，这样可以保证最低的缺页率。

该算法可以保证最低的缺页率，但实际上，只有在进程执行过程中才能知道接下来会访问到的是哪个页面。操作系统无法提前预判页面访问序列。因此，最佳置换算法**无法实现**。

## 先进先出置换算法（FIFO）

每次选择淘汰的页面是最早进入内存的页面。

根据进入内存顺序构成一个队列，淘汰时只需选择队头即可。

> Belady异常：当为进程分配的无礼块数增大时，缺页次数不减反增的异常现象。

**只有FIFO算法会产生Belady异常**。虽然FIFO实现简单，但是与进程实际运行时的规律不适应，因为先进入的页面也有可能最经常被访问。因此算法性能差。

## 最近最久未使用置换算法（LRU）

每次淘汰的页面是最近最久未使用的页面。

<img :src="$withBase='/img/os-page-replace-1.png'" class="align-center" />

赋予每个页面对应的页表项，用**访问字段**记录该页面**自上次被访问以来所经历的时间t**。当需要淘汰一个页面时，选择现有页面中t值最大的，即最近最久未使用的页面。

该算法的实现需要专门硬件支持，虽然算法性能好，但是实现困难，开销大

## 时钟置换算法（CLOCK）

又叫最近未使用算法（NRU，Not Recently Used）

<img :src="$withBase='/img/os-page-replace-1.png'" class="align-center" />

每个页面有一个访问位，内存中的页面都通过链接指针链接成一个循环队列。页面被访问时，访问位置1。需要淘汰时，循环检查页面，直到找到一个访问位是0的，并且在循环过程中，将访问位是1的置为0。一轮扫描过后如果没有换出，则第二轮必定有换出。

## 改进型的时钟置换算法

不仅考虑一个页面是否被访问过，还要考虑页面是否被修改过。

> 只有修改过的页面被淘汰时，才需要写回外存

算法规则：将所有可能被置换的页面排成一个循环队列

1. 第一轮，从当前位置开始扫描到第一个(0,0)的帧用于替换（优先未访问且未修改）
2. 第二轮，第一轮失败，重新扫描，查找第一个(0,1)的帧用于替换，且将扫描过的帧访问位设为0（优先未访问且已修改）
3. 第三轮，第二轮失败，查找第一个(0,0)的帧用于替换（优先已访问且未修改）
4. 第四轮，第三轮失败，查找第一个(0,1)的帧用于替换（优先已访问且已修改）

由于第二轮已将所有的访问位置为0，因此第三轮或者第四轮必会选中一个