# 分片集群

主从集群和哨兵集群可以解决高可用、高并发读的问题。但是依然有两个问题没有解决

- 海量数据存储问题
- 高并发写的问题

使用分片集群可以解决上述问题，分片集群特征为：

- 集群中有多个master，每个master保存不同数据
- 每个master都可以有多个slave
- master之间通过ping监测批次健康状态
- 客户端请求可以访问集群任意节点，最终都会被转发到正确的节点上

## 散列插槽

Redis会把每一个master节点映射到0-16383共16384个插槽（hash slot）上。

分片集群中，数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：

1. key中包含"{}"，且"{}"中至少包含一个字符，"{}"中的部分是有效部分
2. key中不包含"{}"，整个key是有效部分

例如，key是num，那么num整体是有效部分，如果是{itcast}num，则itcast是有效部分。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是插槽值。

插槽值决定的是当前key存放在哪个插槽上，也就是哪个master节点上。

## 集群伸缩

向集群中添加新节点，或删除节点，注意集群节点发生改变后，插槽的分割与关联改变。

## 故障转移

当集群中有一个master宕机之后

1. 首先集群中该节点是疑似宕机状态，接着转变为确认下线状态，然后集群自动提升该节点的一个slave节点为新的master
2. 宕机节点恢复后，自动转为新master节点的slave节点

## 数据迁移

利用`cluster failover`命令可以手动让集中中某个master宕机，切换到执行`cluster failover`命令的这个slave节点，实现无感知的数据迁移。

### 命令参数

- 缺省：执行如下流程，6步操作
- force：省略了对offset的一致性校验
- takeover：直接执行第5步，忽略数据一致性、忽略master状态和其它master意见

### 流程

1. slave节点执行`cluster failover`命令，告知其对应的master节点拒绝任何客户端请求
2. 其master节点返回当前数据的offset给slave节点
3. slave等待offset与master一致
4. 开始故障转移
5. slave标记自己为master节点，并广播通知其余master节点故障转移结果
6. 原master节点收到广播通知后，开始作为新master的slave节点处理客户端请求或者下线等等

## 注意

1. redis的key与插槽绑定而不是节点绑定，因为节点有可能宕机，但是如果跟插槽绑定，当节点宕机时，会有slave节点顶替上来，还是对应原来插槽的位置。