# 缓存击穿

> 又叫热点Key问题，就是一个高并发访问并且缓存重建业务较复杂的Key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击
>
> - 高并发访问：指该缓存key访问量非常频繁
> - 缓存重建业务复杂：指重新构建缓存数据时，需要通过复杂的业务逻辑来计算出需要缓存的值，比如多表数据联查组合等等

## 解决方案

两种解决方案中的互斥锁都可以通过`redis`的`setnx`来实现。

### 互斥锁

指的是在重建缓存时需要先获得锁才能开始进行重建操作

优点：

1. 实现简单
2. 能够保持一致性

缺点：

1. 同一时期，可能导致大量线程都在等待获得锁
2. 如果出现A需要获得B获得的锁，B需要获得A获得的锁，那么会出现死锁

### 逻辑过期

1. 设置额外过期字段，通常为`expire`，保存过期时间，而不再设置TTL来控制过期时间
2. 查询数据时，根据额外字段判断是否过期，如果过期，则获取互斥锁，并开启一个新的线程去重建缓存；原线程直接返回过期数据。

优点：

1. 现成无需等待

缺点：

1. 不能保证一致性，因为会返回过期数据
2. 需要额外缓存一个过期时间字段
3. 实现比较复杂