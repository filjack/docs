# 超卖问题

典型的多线程安全问题，当多个线程共享统一资源时，各线程逻辑交叉执行，会带来线程安全问题。

## 解决方案

### 悲观锁

认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如，synchronized、lock都属于悲观锁

### 乐观锁

认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。

- 如果没有修改则认为是安全的，自己才更新数据
- 如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常

#### 方法

1. 版本号法
2. CAS法（compare and swap比较交换法）

### 分布式锁

> 满足在分布式系统或集群模式下多进程可见并且互斥的锁

#### 实现方式

##### MySQL

利用数据库本身的互斥锁机制实现

##### Redis

利用setnx这样的互斥命令实现，注意设置过期时间，防止因为业务服务宕机导致锁永不过期。

redis的key有两种删除方式（释放锁的方式）

1. 业务结束，业务调用redis删除key
2. 业务阻塞，redis过期时间机制删除key

当出现第二种情况释放锁时，可能会出现误删锁的情况，例如，服务实例A获得锁后，由于业务发生阻塞，且超过了设置的超时时间，锁自动释放，此时服务实例B获取到锁，而与此同时，服务实例A业务阻塞结束了，且业务流程已经结束，实例A要去释放锁，此时需要判断一下锁的value是不是A存入的那个值，避免误删已经不属于A实例自身的锁，从而造成并发问题。



通过LUA语言结合redis保证多条redis命令执行的原子性

##### Zookeeper

利用节点的唯一性和有序性实现

